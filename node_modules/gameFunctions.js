const utils = require('utils')
const communication = require('communication')
const gameFunctions = {
	create: (clients, keys, games, result) =>
	{
		const clientId = result.clientId;
		const host = result.host;
		const isPrivate = result.isPrivate;
		let key = "";
		const gameId = utils.guid();
		if (isPrivate)
		{	
			for (let x = 0; x < 3; x++)
			{
				x ? key += "-" + dictionary.getRandomWord() : key = dictionary.getRandomWord();
			}	
			keys[key] = gameId; 

		} else {
			key = false
		}	
		console.log(`the game is private? ${isPrivate}. the KEY is ${key}`);

		games[gameId] = {
			"id": gameId,
			"hostId": clientId,
			"hostname": host,
			"key": key,
			"inProgress" : false,
			"clients": [],
			"acronyms": [],
			"currentRound": 1,
			"roundTimer" : null,
			"acceptingAnswers" : false,
			"answers": [],
			"joinable": true
		}

		const payload = {
			"method": "create",
			"game" : games[gameId]
		}

		communication.send(clients[clientId], payload)
		/*const con = clients[clientId].connection;
		con.send(JSON.stringify(payload));*/
	},
	makeAcronym: (length) =>
	{
	    let result           = '';
	    let characters       = 'AAAABBBCCCDDDDEEEEFFFFGGGGHHHIIIIIJKLLLLMMMMMNNNNNNOOOOPPPPPQRRRRRRSSSSSSSTTTTTTUUVVWWWXYYYZ';
	    let charactersLength = characters.length;
		    for ( var i = 0; i < length; i++ ) {
		      a = characters.charAt(Math.floor(Math.random() * 
		 		charactersLength));
		      result += a; //characters.charAt(Math.floor(Math.random() * 
		 		//charactersLength));
			}
		return result;  
	},
	castVote: (clients, game, result) =>
	{
		const clientId = result.clientId;
		const ownerId = result.ownerId;
		const gameId = result.gameId;
		console.log("**** cast vote");
		console.log(result);
		communication.dm(clients, clientId, "vote received.");
		clients[clientId].currentGameInfo.vote = ownerId;		
	},
	play: (clients, game, result) =>
	{
		const clientId = result.clientId;
		if (game.acceptingAnswers)
		{	
			const play = result.play;
			if (clients[clientId].currentGameInfo.play == null) {
				communication.broadcast(clients, game, "someone answered.")
			} else {
				communication.broadcast(clients, game, "someone changed their answer.")
			}
			clients[clientId].currentGameInfo.play = play;
		}
		else
		{
			dm(clientId, "sorry, round is over!");
		}	
	},
	start: (clients, game, result) =>
	{
		gameFunctions.setup(game);
		gameFunctions.startRound(clients, game);
	},
	setup: (game) => 
	{
		game.inProgress = true;
		for (let x = 0; x < 7; x++)
		{
			var min, max;
			let outlier = utils.randomInt(1,100);
			if (outlier < 33) {
				min = 2;
				max = 5;
			} else {
				min = 3;
				max = 4;
			}
			game.acronyms.push(gameFunctions.makeAcronym(utils.randomInt(min, max)));	
		}				
	},
	startRound: (clients, game) =>
	{
		if (game.clients.length == 0)
		{
			delete game;
			return;
		}		
		game.acceptingAnswers = true;
		const payload = {
			"method" : "startRound",
			"round" : game.currentRound,
			"acronym" : game.acronyms[game.currentRound - 1]
		}
		communication.sendAll(clients, game, payload);
		setTimeout(() => {
		  communication.broadcast(clients, game, "30 seconds left.")
			setTimeout(() => {
			  communication.broadcast(clients, game, "15 seconds. it's more than it sounds.")
				setTimeout(() => {
				  warning(game, "<span id='counter'>5</span>") 
				  	setTimeout(() => {
						  gameFunctions.cullAnswers(game) 			  	
					}, 5000);			  	
				}, 10000);	 		  
			}, 15000);	  
		}, 30000);
	},
	cullAnswers: (game) =>
	{
		console.log("here's all the answers");
		game.clients.forEach (c => {
			var answer = {
				owner: c.clientId,
				acronym: clients[c.clientId].currentGameInfo.play
			};
			game.answers.push(answer);
			
		});
		console.log(game.answers)

		if (game.answers.length > 1)
		{
				gameFunctions.getVotes(game);
		}	else {
				gameFunctions.skipVoting(game)
		}
	},
	getVotes: (game) =>
	{
		communication.broadcast(clients, game, "30 seconds to vote");
		game.acceptingAnswers = false;								 
		const payload = {
			"method" : "getVotes",
			"answers": JSON.stringify(game.answers)
		}
		communication.sendAll(clients, game, payload);
		setTimeout(() => {
			warning(game, "<span id='counter'>5</span>") 
			setTimeout(() => {
				gameFunctions.cullVotes(game);	  			  		  			  	 			  		  			  	
			}, 5500);			  			  	
		}, 24500);	
	},
	skipVoting: (game) =>
	{
		game.acceptingAnswers = false;	
	  
		let answers = [];
		for (var x = 0; x < game.answers.length; x++)
		{
			answers.push({
				nick: clients[game.answers[x].owner].currentGameInfo.nick,
				owner: game.answers[x].owner,
				acronym: game.answers[x].acronym
		  	});
		}	
		const payload = {
				"method" : "skipVoting",
				"answers": JSON.stringify(answers)
		}
		communication.sendAll(clients, game, payload);
		gameFunctions.endRound(game);
		if (game.currentRound >= game.acronyms.length)
		{
			let score = []
			game.clients.forEach (c => {
				let player = clients[c.clientId];
				score.push({
							"clientId": c.clientId,
							"nick" : clients[c.clientId].currentGameInfo.nick,
							"score": clients[c.clientId].currentGameInfo.scoreTotal
						})
			});	
			gameFunctions.endGame(game, score[0]);
		}	
		else
		{
			communication.broadcast(clients, game, "next round starts in 30 seconds")
			setTimeout(() => {
				gamefunctions.startRound(game);			  			  	
			}, 30000);				
		}		
	},
	cullVotes: (game) =>
	{
		game.clients.forEach (c => {
			if (c.clientId === clients[c.clientId].currentGameInfo.vote)
			{
				clients[c.clientId].currentGameInfo.selfVoted = true;
			}	
			else if (clients[c.clientId].currentGameInfo.vote === null)
			{
				clients[c.clientId].currentGameInfo.didNotVote = true;
			}
			else
			{
				let voter = clients[c.clientId];
				let votee = clients[voter.currentGameInfo.vote]
				votee.currentGameInfo.votesReceived += 1;
			}	
		});
		gameFunctions.calculateRoundResult(game);
		gameFunctions.reportRoundResult(game); 
		gameFunctions.endRound(game);
		let score = gameFunctions.reportScore(game);
		gameFunctions.advanceOrEnd(game, score);		
	},
	calculateRoundResult: (game) =>
	{
		game.clients.forEach (c => {
			let player = clients[c.clientId];
			let adjuster = player.currentGameInfo.selfVoted || player.currentGameInfo.didNotVote ? 6 : 0;
			player.currentGameInfo.roundScore = (player.currentGameInfo.votesReceived * 5) - adjuster;
			if (player.currentGameInfo.roundScore < 0)
			{
				player.currentGameInfo.roundScore = 0;	
			}	
			console.log(player.currentGameInfo)
		});
	},
	reportRoundResult: (game) =>
	{
		let result = [];
		game.clients.forEach (c => {
			let player = clients[c.clientId];
			result.push({
				"nick":             player.currentGameInfo.nick,
				"acronym": 			player.currentGameInfo.play,
				"votesReceived" : 	player.currentGameInfo.votesReceived,
				"didNotVote" : 		player.currentGameInfo.didNotVote,
				"selfVoted" : 		player.currentGameInfo.selfVoted,
				"roundScore" : 		player.currentGameInfo.roundScore
			})
		});	
		const payload = {
			"method" : "reportRoundResult",
			"roundResult": result
		}	
		communication.sendAll(clients, game, payload);	
	},	
	endRound: (game) =>
	{
		game.clients.forEach (c => {
			console.log("ENDING ROUND, ADDING SCORES")
			clients[c.clientId].currentGameInfo.scoreTotal += clients[c.clientId].currentGameInfo.roundScore; 
			clients[c.clientId].currentGameInfo.roundScore = 0;
			clients[c.clientId].currentGameInfo.votesReceived = 0;
			clients[c.clientId].currentGameInfo.didNotVote = false;
			clients[c.clientId].currentGameInfo.selfVoted = false;
			clients[c.clientId].currentGameInfo.play = null;
			clients[c.clientId].currentGameInfo.vote = null;
		});
		game.answers = [];
		game.currentRound++;
	},
	reportScore: (game) =>
	{
		let score = []
		game.clients.forEach (c => {
			let player = clients[c.clientId];
			score.push({
				"clientId": c.clientId,
				"nick" : clients[c.clientId].currentGameInfo.nick,
				"score": clients[c.clientId].currentGameInfo.scoreTotal
			})
		});	
		const payload = {
			"method" : "reportScore",
			"score": JSON.stringify(score)
		}
		communication.sendAll(clients, game, payload);	
		return score;	
	},	
	advanceOrEnd: (game, score) =>
	{
		if (game.currentRound >= game.acronyms.length)
		{
			gameFunctions.endGame(game, score[0]);
		}	
		else
		{
			communication.broadcast(clients, game, "next round starts in 30 seconds")
			setTimeout(() => {
				gameFunctions.startRound(game);			  			  	
			}, 30000);				
		}
	},
	endGame: (game, winner) =>
	{
		let payload = {
			"method":   "endGame",
			"hostId":   game.hostId,
			"clientId": winner.clientId,
			"nick"  :   clients[winner.clientId].currentGameInfo.nick,
			"score" :   winner.score
		}
		communication.sendAll(clients, game, payload);	
		game.clients.forEach (c => {
				clients[c.clientId].currentGameInfo.scoreTotal = 0;
		});
		game.currentRound = 1;
		game.acronyms = [];		
	},
	checkIfGameIsDead: (game) =>
	{
		if (game.clients.length < 1)
			gameFunctions.killGame(game);			
	},
	killGame: (game, keys) =>
	{
		if (game.key)
			delete keys[game.key];    // if the game is private, find its entry in the master list of private keys and kill it

		delete games[game.id];       // then kill the game itself
	},
	exit: (clients, clientId, game) =>
	{
		const client = clients[clientId];
		const payload = {
			"method" : "exitSuccess"
		}
		gameFunctions.cullDeadClientsFromGame(game, clientId);
		communication.send(client, payload);
		communication.broadcast(clients, game, `${client.currentGameInfo.nick} left.`)  
		gameFunctions.resetPlayer(clients[clientId]);

		if (game.hostId == clientId)
		{
			game.joinable = false;
			console.log("host exited, aborting game");	
			communication.broadcast(clients, game, "host left. exiting in 5 seconds!")	
			communication.warning(clients, game, "5")						
			setTimeout(() => {
				for (let x = 0; x < game.clients.length; x++)
				{
					gameFunctions.resetPlayer(clients[game.clients[x].clientId]);
				}					
				communication.sendAll(clients, game, payload);
				gameFunctions.killGame(game);		
			}, 5000 );	
		}	
	},
	cullAllClients: (game) =>
	{
		game.clients.length = 0;
	},
	cullDeadClientsFromGame: (game, clientId) =>
	{
		for (let x = 0; x < game.clients.length; x++)
		{
			if (game.clients[x].clientId == clientId)
			{
				game.clients.splice(x, 1); // found the client to cull
				gameFunctions.checkIfGameIsDead(game); // check to see if they were the only one left, and the game needs to die
			}	
		}
	},
	resetPlayer: (client) =>
	{
		client.currentGameInfo.gameId = null;
		client.currentGameInfo.roundScore = 0;
		client.currentGameInfo.scoreTotal = 0;
		client.currentGameInfo.votesReceived = 0;
		client.currentGameInfo.won = false;
		client.currentGameInfo.selfVoted = false;
		client.currentGameInfo.didNotVote = false;
		client.currentGameInfo.play = null;
		client.currentGameInfo.vote = null;		
	}
}

module.exports = gameFunctions