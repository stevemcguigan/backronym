const utils = require('utils')
const communication = require('communication')
const gameFunctions = {
	create: (clients, games, result) =>
	{
		const clientId = result.clientId;
		const host = result.host;
		const isPrivate = result.isPrivate;
		let key = "";
		const gameId = utils.guid();
		if (isPrivate)
		{	
			for (let x = 0; x < 3; x++)
			{
				x ? key += "-" + dictionary.getRandomWord() : key = dictionary.getRandomWord();
			}	
			keys[key] = gameId; 

		} else {
			key = false
		}	
		console.log(`the game is private? ${isPrivate}. the KEY is ${key}`);

		games[gameId] = {
			"id": gameId,
			"hostId": clientId,
			"hostname": host,
			"key": key,
			"inProgress" : false,
			"clients": [],
			"acronyms": [],
			"currentRound": 1,
			"roundTimer" : null,
			"acceptingAnswers" : false,
			"answers": [],
			"joinable": true
		}

		const payload = {
			"method": "create",
			"game" : games[gameId]
		}

		communication.send(clients[clientId], payload)
		/*const con = clients[clientId].connection;
		con.send(JSON.stringify(payload));*/
	},
	makeAcronym: (length) =>
	{
	    let result           = '';
	    let characters       = 'AAAABBBCCCDDDDEEEEFFFFGGGGHHHIIIIIJKLLLLMMMMMNNNNNNOOOOPPPPPQRRRRRRSSSSSSSTTTTTTUUVVWWWXYYYZ';
	    let charactersLength = characters.length;
		    for ( var i = 0; i < length; i++ ) {
		      a = characters.charAt(Math.floor(Math.random() * 
		 		charactersLength));
		      result += a; //characters.charAt(Math.floor(Math.random() * 
		 		//charactersLength));
			}
		return result;  
	},
	castVote: (clients, game, result) =>
	{
		const clientId = result.clientId;
		const ownerId = result.ownerId;
		const gameId = result.gameId;
		console.log("**** cast vote");
		console.log(result);
		communication.dm(clients, clientId, "vote received.");
		clients[clientId].currentGameInfo.vote = ownerId;		
	},
	play: (clients, game, result) =>
	{
		const clientId = result.clientId;
		if (game.acceptingAnswers)
		{	
			const play = result.play;
			if (clients[clientId].currentGameInfo.play == null) {
				communication.broadcast(clients, game, "someone answered.")
			} else {
				communication.broadcast(clients, game, "someone changed their answer.")
			}
			clients[clientId].currentGameInfo.play = play;
		}
		else
		{
			dm(clientId, "sorry, round is over!");
		}	
	},
	start: (game) =>
	{
		gameFunctions.setup(game);
		gameFunctions.startRound(game);
	},
	setup: (game) => 
	{
		game.inProgress = true;
		for (let x = 0; x < 7; x++)
		{
			var min, max;
			let outlier = utils.randomInt(1,100);
			if (outlier < 33) {
				min = 2;
				max = 5;
			} else {
				min = 3;
				max = 4;
			}
			game.acronyms.push(gameFunctions.makeAcronym(utils.randomInt(min, max)));	
		}				
	},
	startRound: (game) =>
	{
		if (game.clients.length == 0)
		{
			delete game;
			return;
		}		
		game.acceptingAnswers = true;
		const payload = {
			"method" : "startRound",
			"round" : game.currentRound,
			"acronym" : game.acronyms[game.currentRound - 1]
		}
		communication.sendAll(clients, game, payload);
		setTimeout(() => {
		  communication.broadcast(clients, game, "30 seconds left.")
			setTimeout(() => {
			  communication.broadcast(clients, game, "15 seconds. it's more than it sounds.")
				setTimeout(() => {
				  warning(game, "<span id='counter'>5</span>") 
				  	setTimeout(() => {
						  cullAnswers(game) 			  	
					}, 5000);			  	
				}, 10000);	 		  
			}, 15000);	  
		}, 30000);
	}
}

module.exports = gameFunctions